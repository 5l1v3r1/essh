package essh

import (
	"bytes"
	"github.com/yuin/gopher-lua"
	"sort"
	"strings"
	"text/template"
)

type Host struct {
	Name        string
	Props       map[string]string
	Hooks       map[string][]interface{}
	Description string
	Hidden      bool
	Tags        []string
	Registry    *Registry
	Private     bool

	sshConfig *lua.LTable
	lconfig   *lua.LTable
}

//
// Spec note about Hosts (it is a little complicated!):
//   Hosts are stored into a space: "global" or "local" which are called as 'registry' (or 'context').
//   The registry is determined by a place of the configuration file that hosts are defined in.
//
//   Example:
//     /etc/essh/config.lua              -> "global"
//     ~/.essh/config.lua                -> "global"
//     /path/to/project/esshconfig.lua   -> "local"
//
//   Hosts also have configuration "scope". There are two types of scope: "public" and "private".
//
//   There are some rules about operating hosts.
//     * Each public hosts must be unique. (You can NOT define public hosts by the same name in the local and global registry.)
//     * Any hosts must be unique in a same registry. (You can NOT define hosts by the same name in the same registry.)
//     * Hosts used by task must be defined in a same registry. (Tasks can refer to only hosts defined in the same registry.)
//     * Private hosts is only used by tasks.
//     * There can be duplicated hosts in the entire registries. (You can define private hosts even if you define same name public hosts.)
//

func (h *Host) SortedSSHConfig() []map[string]string {
	values := []map[string]string{}

	var names []string

	h.sshConfig.ForEach(func(k lua.LValue, v lua.LValue) {
		if keystr, ok := toString(k); ok {
			names = append(names, keystr)
		}
	})

	sort.Strings(names)

	for _, name := range names {
		lvalue := h.sshConfig.RawGetString(name)
		if svalue, ok := toString(lvalue); ok {
			// can use only string value.
			value := map[string]string{name: svalue}
			values = append(values, value)
		}
	}

	return values
}

func (h *Host) DescriptionOrDefault() string {
	if h.Description == "" {
		return h.Name + " host"
	}

	return h.Description
}

func (h *Host) Scope() string {
	if h.Private {
		return "private"
	} else {
		return "public"
	}
}

func GetPublicHost(hostname string) *Host {
	for _, h := range SortedPublicHosts() {
		if h.Name == hostname {
			return h
		}
	}

	return nil
}

func SortedHosts() []*Host {
	names := []string{}
	namesMap := map[string]bool{}
	hosts := []*Host{}

	for name, _ := range GlobalRegistry.Hosts {
		if namesMap[name] {
			// already registerd to names
			continue
		}

		names = append(names, name)
		namesMap[name] = true
	}

	for name, _ := range LocalRegistry.Hosts {
		if namesMap[name] {
			// already registerd to names
			continue
		}

		names = append(names, name)
		namesMap[name] = true
	}

	sort.Strings(names)

	for _, name := range names {
		if h, ok := GlobalRegistry.Hosts[name]; ok {
			hosts = append(hosts, h)
		}

		if h, ok := LocalRegistry.Hosts[name]; ok {
			hosts = append(hosts, h)
		}
	}

	return hosts
}

func SortedPublicHosts() []*Host {
	hosts := []*Host{}

	for _, h := range SortedHosts() {
		if !h.Private {
			hosts = append(hosts, h)
		}
	}

	return hosts
}

func SameRegistryHosts(contextType int) []*Host {
	hosts := []*Host{}

	for _, host := range SortedHosts() {
		if host.Registry.Type == contextType {
			hosts = append(hosts, host)
		}
	}

	return hosts
}

var hostsTemplate = `# Generated by using https://github.com/kohkimakimoto/essh
# Don't edit this file manually.
{{range $i, $host := .Hosts}}
Host {{$host.Name}}{{range $ii, $param := $host.SortedSSHConfig}}{{range $k, $v := $param}}
    {{$k}} {{$v}}{{end}}{{end}}
{{end}}
`

func GenHostsConfig(enabledHosts []*Host) ([]byte, error) {
	tmpl, err := template.New("T").Parse(hostsTemplate)
	if err != nil {
		return nil, err
	}

	input := map[string]interface{}{"Hosts": enabledHosts}
	var b bytes.Buffer
	if err := tmpl.Execute(&b, input); err != nil {
		return nil, err
	}

	return b.Bytes(), nil
}

func Tags() []string {
	tagsMap := map[string]string{}
	tags := []string{}

	for _, host := range SortedHosts() {
		for _, t := range host.Tags {
			if _, exists := tagsMap[t]; !exists {
				tagsMap[t] = t
				tags = append(tags, t)
			}
		}
	}

	sort.Strings(tags)

	return tags
}

func FindHostsInRegistry(names []string, registryType int) []*Host {
	var hosts = []*Host{}

	for _, host := range SortedHosts() {
		if host.Registry.Type != registryType {
			continue
		}

	B1:
		for _, name := range names {
			if host.Name == name {
				hosts = append(hosts, host)
				break B1
			}
		}

	B2:
		for _, tag := range host.Tags {
			for _, name := range names {
				if tag == name {
					hosts = append(hosts, host)
					break B2
				}
			}
		}
	}

	return hosts
}

func FindPublicHosts(names []string) []*Host {
	var hosts = []*Host{}

	for _, host := range SortedPublicHosts() {
	B1:
		for _, name := range names {
			if host.Name == name {
				hosts = append(hosts, host)
				break B1
			}
		}

	B2:
		for _, tag := range host.Tags {
			for _, name := range names {
				if tag == name {
					hosts = append(hosts, host)
					break B2
				}
			}
		}
	}

	return hosts
}

func HostsByNames(names []string) []*Host {
	var hosts = []*Host{}

	for _, host := range SortedHosts() {
	B1:
		for _, name := range names {
			if host.Name == name {
				hosts = append(hosts, host)
				break B1
			}
		}

	B2:
		for _, tag := range host.Tags {
			for _, name := range names {
				if tag == name {
					hosts = append(hosts, host)
					break B2
				}
			}
		}
	}

	return hosts
}

func HostsByTag(name string, isOnlyPublic bool) []*Host {
	var hosts = []*Host{}

	for _, host := range SortedHosts() {
	B1:
		for _, tag := range host.Tags {
			if tag == name {
				if isOnlyPublic {
					if !host.Private {
						hosts = append(hosts, host)
					}
				} else {
					hosts = append(hosts, host)
					break B1
				}
			}
		}
	}

	return hosts
}

func HostnameAlignString(host *Host, hosts []*Host) func(string) string {
	var maxlen int
	for _, h := range hosts {
		size := len(h.Name)
		if maxlen < size {
			maxlen = size
		}
	}

	var namelen = len(host.Name)
	return func(s string) string {
		diff := maxlen - namelen
		return strings.Repeat(s, 1+diff)
	}
}
